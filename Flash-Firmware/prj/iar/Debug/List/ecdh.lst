###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.5.9725/W32 for ARM        28/Oct/2023  18:58:36
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\core\ftl\ecdh.c
#    Command line =  
#        C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\core\ftl\ecdh.c -D
#        BOOT_LEVEL_2 -lcN
#        C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\prj\iar\Debug\List -o
#        C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\prj\iar\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM926EJ-S -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\prj\iar\..\..\ -I
#        C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\prj\iar\..\..\sys\lpc313x\bsp\
#        -I
#        C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\prj\iar\..\..\sys\lpc313x\csp\
#        -I
#        C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\prj\iar\..\..\sys\lpc313x\lib\
#        -I
#        C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\prj\iar\..\..\sys\lpc313x\usb\
#        --cpu_mode thumb -Ol --use_c++_inline
#    List file    =  
#        C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\prj\iar\Debug\List\ecdh.lst
#    Object file  =  
#        C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\prj\iar\Debug\Obj\ecdh.o
#
###############################################################################

C:\Users\bchen-adm\Desktop\nsac-hiftl-dc\core\ftl\ecdh.c
      1          /* 
      2             Taken from github.com/kokke/tiny-ECDH-c
      3          
      4            Crypto using elliptic curves defined over the finite binary field GF(2^m) where m is prime.
      5          
      6            The curves used are the anomalous binary curves (ABC-curves) or also called Koblitz curves.
      7          
      8            This class of curves was chosen because it yields efficient implementation of operations.
      9          
     10          
     11          
     12            Curves available - their different NIST/SECG names and eqivalent symmetric security level:
     13          
     14                NIST      SEC Group     strength
     15              ------------------------------------
     16                K-163     sect163k1      80 bit
     17                B-163     sect163r2      80 bit
     18                K-233     sect233k1     112 bit
     19                B-233     sect233r1     112 bit
     20                K-283     sect283k1     128 bit
     21                B-283     sect283r1     128 bit
     22                K-409     sect409k1     192 bit
     23                B-409     sect409r1     192 bit
     24                K-571     sect571k1     256 bit
     25                B-571     sect571r1     256 bit
     26          
     27          
     28            Curve parameters from:
     29          
     30              http://www.secg.org/sec2-v2.pdf
     31              http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf
     32          
     33          
     34            Reference:
     35          
     36              https://www.ietf.org/rfc/rfc4492.txt 
     37          */
     38          
     39          #include <stdint.h>
     40          #include "ecdh.h"
     41          
     42          
     43          /* margin for overhead needed in intermediate calculations */
     44          #define BITVEC_MARGIN     3
     45          #define BITVEC_NBITS      (CURVE_DEGREE + BITVEC_MARGIN)
     46          #define BITVEC_NWORDS     ((BITVEC_NBITS + 31) / 32)
     47          #define BITVEC_NBYTES     (sizeof(uint32_t) * BITVEC_NWORDS)
     48          
     49          
     50          /* Disable assertions? */
     51          #ifndef DISABLE_ASSERT
     52           #define DISABLE_ASSERT 0
     53          #endif
     54          
     55          #if defined(DISABLE_ASSERT) && (DISABLE_ASSERT == 1)
     56           #define assert(...)
     57          #else
     58           #include <assert.h>
     59          #endif
     60          
     61          /* Default to a (somewhat) constant-time mode?
     62             NOTE: The library is _not_ capable of operating in constant-time and leaks information via timing.
     63                   Even if all operations are written const-time-style, it requires the hardware is able to multiply in constant time. 
     64                   Multiplication on ARM Cortex-M processors takes a variable number of cycles depending on the operands...
     65          */
     66          #ifndef CONST_TIME
     67            #define CONST_TIME 0
     68          #endif
     69          
     70          /* Default to using ECC_CDH (cofactor multiplication-variation) ? */
     71          #ifndef ECDH_COFACTOR_VARIANT
     72            #define ECDH_COFACTOR_VARIANT 0
     73          #endif
     74          
     75          /******************************************************************************/
     76          
     77          
     78          /* the following type will represent bit vectors of length (CURVE_DEGREE+MARGIN) */
     79          typedef uint32_t bitvec_t[BITVEC_NWORDS];
     80          typedef bitvec_t gf2elem_t;           /* this type will represent field elements */
     81          typedef bitvec_t scalar_t;
     82           
     83          
     84          /******************************************************************************/
     85          
     86          /* Here the curve parameters are defined. */
     87          
     88          #if defined (ECC_CURVE) && (ECC_CURVE != 0)
     89           #if (ECC_CURVE == NIST_K163)
     90            #define coeff_a  1
     91            #define cofactor 2
     92          /* NIST K-163 */
     93          const gf2elem_t polynomial = { 0x000000c9, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000008 }; 
     94          const gf2elem_t coeff_b    = { 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 }; 
     95          const gf2elem_t base_x     = { 0x5c94eee8, 0xde4e6d5e, 0xaa07d793, 0x7bbc11ac, 0xfe13c053, 0x00000002 }; 
     96          const gf2elem_t base_y     = { 0xccdaa3d9, 0x0536d538, 0x321f2e80, 0x5d38ff58, 0x89070fb0, 0x00000002 }; 
     97          const scalar_t  base_order = { 0x99f8a5ef, 0xa2e0cc0d, 0x00020108, 0x00000000, 0x00000000, 0x00000004 }; 
     98           #endif
     99          
    100           #if (ECC_CURVE == NIST_B163)
    101            #define coeff_a  1
    102            #define cofactor 2
    103          /* NIST B-163 */
    104          const gf2elem_t polynomial = { 0x000000c9, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000008 }; 
    105          const gf2elem_t coeff_b    = { 0x4a3205fd, 0x512f7874, 0x1481eb10, 0xb8c953ca, 0x0a601907, 0x00000002 }; 
    106          const gf2elem_t base_x     = { 0xe8343e36, 0xd4994637, 0xa0991168, 0x86a2d57e, 0xf0eba162, 0x00000003 }; 
    107          const gf2elem_t base_y     = { 0x797324f1, 0xb11c5c0c, 0xa2cdd545, 0x71a0094f, 0xd51fbc6c, 0x00000000 }; 
    108          const scalar_t  base_order = { 0xa4234c33, 0x77e70c12, 0x000292fe, 0x00000000, 0x00000000, 0x00000004 }; 
    109           #endif
    110          
    111           #if (ECC_CURVE == NIST_K233)
    112            #define coeff_a  0
    113            #define cofactor 4
    114          /* NIST K-233 */
    115          const gf2elem_t polynomial = { 0x00000001, 0x00000000, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000200 };
    116          const gf2elem_t coeff_b    = { 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 };
    117          const gf2elem_t base_x     = { 0xefad6126, 0x0a4c9d6e, 0x19c26bf5, 0x149563a4, 0x29f22ff4, 0x7e731af1, 0x32ba853a, 0x00000172 };
    118          const gf2elem_t base_y     = { 0x56fae6a3, 0x56e0c110, 0xf18aeb9b, 0x27a8cd9b, 0x555a67c4, 0x19b7f70f, 0x537dece8, 0x000001db };
    119          const scalar_t  base_order = { 0xf173abdf, 0x6efb1ad5, 0xb915bcd4, 0x00069d5b, 0x00000000, 0x00000000, 0x00000000, 0x00000080 };
    120           #endif
    121          
    122           #if (ECC_CURVE == NIST_B233)
    123            #define coeff_a  1
    124            #define cofactor 2
    125          /* NIST B-233 */
    126          const gf2elem_t polynomial = { 0x00000001, 0x00000000, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000200 }; 
    127          const gf2elem_t coeff_b    = { 0x7d8f90ad, 0x81fe115f, 0x20e9ce42, 0x213b333b, 0x0923bb58, 0x332c7f8c, 0x647ede6c, 0x00000066 }; 
    128          const gf2elem_t base_x     = { 0x71fd558b, 0xf8f8eb73, 0x391f8b36, 0x5fef65bc, 0x39f1bb75, 0x8313bb21, 0xc9dfcbac, 0x000000fa }; 
    129          const gf2elem_t base_y     = { 0x01f81052, 0x36716f7e, 0xf867a7ca, 0xbf8a0bef, 0xe58528be, 0x03350678, 0x6a08a419, 0x00000100 }; 
    130          const scalar_t  base_order = { 0x03cfe0d7, 0x22031d26, 0xe72f8a69, 0x0013e974, 0x00000000, 0x00000000, 0x00000000, 0x00000100 };
    131           #endif
    132          
    133           #if (ECC_CURVE == NIST_K283)
    134            #define coeff_a  0
    135            #define cofactor 4
    136          /* NIST K-283 */
    137          const gf2elem_t polynomial = { 0x000010a1, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x08000000 };
    138          const gf2elem_t coeff_b    = { 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 }; 
    139          const gf2elem_t base_x     = { 0x58492836, 0xb0c2ac24, 0x16876913, 0x23c1567a, 0x53cd265f, 0x62f188e5, 0x3f1a3b81, 0x78ca4488, 0x0503213f }; 
    140          const gf2elem_t base_y     = { 0x77dd2259, 0x4e341161, 0xe4596236, 0xe8184698, 0xe87e45c0, 0x07e5426f, 0x8d90f95d, 0x0f1c9e31, 0x01ccda38 }; 
    141          const scalar_t  base_order = { 0x1e163c61, 0x94451e06, 0x265dff7f, 0x2ed07577, 0xffffe9ae, 0xffffffff, 0xffffffff, 0xffffffff, 0x01ffffff }; 
    142           #endif
    143          
    144           #if (ECC_CURVE == NIST_B283)
    145            #define coeff_a  1
    146            #define cofactor 2
    147          /* NIST B-283 */
    148          const gf2elem_t polynomial = { 0x000010a1, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x08000000 }; 
    149          const gf2elem_t coeff_b    = { 0x3b79a2f5, 0xf6263e31, 0xa581485a, 0x45309fa2, 0xca97fd76, 0x19a0303f, 0xa5a4af8a, 0xc8b8596d, 0x027b680a }; 
    150          const gf2elem_t base_x     = { 0x86b12053, 0xf8cdbecd, 0x80e2e198, 0x557eac9c, 0x2eed25b8, 0x70b0dfec, 0xe1934f8c, 0x8db7dd90, 0x05f93925 }; 
    151          const gf2elem_t base_y     = { 0xbe8112f4, 0x13f0df45, 0x826779c8, 0x350eddb0, 0x516ff702, 0xb20d02b4, 0xb98fe6d4, 0xfe24141c, 0x03676854 }; 
    152          const scalar_t  base_order = { 0xefadb307, 0x5b042a7c, 0x938a9016, 0x399660fc, 0xffffef90, 0xffffffff, 0xffffffff, 0xffffffff, 0x03ffffff }; 
    153           #endif
    154          
    155           #if (ECC_CURVE == NIST_K409)
    156            #define coeff_a  0
    157            #define cofactor 4
    158          /* NIST K-409 */
    159          const gf2elem_t polynomial = { 0x00000001, 0x00000000, 0x00800000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02000000 }; 
    160          const gf2elem_t coeff_b    = { 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 }; 
    161          const gf2elem_t base_x     = { 0xe9023746, 0xb35540cf, 0xee222eb1, 0xb5aaaa62, 0xc460189e, 0xf9f67cc2, 0x27accfb8, 0xe307c84c, 0x0efd0987, 0x0f718421, 0xad3ab189, 0x658f49c1, 0x0060f05f }; 
    162          const gf2elem_t base_y     = { 0xd8e0286b, 0x5863ec48, 0xaa9ca27a, 0xe9c55215, 0xda5f6c42, 0xe9ea10e3, 0xe6325165, 0x918ea427, 0x3460782f, 0xbf04299c, 0xacba1dac, 0x0b7c4e42, 0x01e36905 }; 
    163          const scalar_t  base_order = { 0xe01e5fcf, 0x4b5c83b8, 0xe3e7ca5b, 0x557d5ed3, 0x20400ec4, 0x83b2d4ea, 0xfffffe5f, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x007fffff }; 
    164           #endif
    165          
    166           #if (ECC_CURVE == NIST_B409)
    167            #define coeff_a  1
    168            #define cofactor 2
    169          /* NIST B-409 */
    170          const gf2elem_t polynomial = { 0x00000001, 0x00000000, 0x00800000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02000000 }; 
    171          const gf2elem_t coeff_b    = { 0x7b13545f, 0x4f50ae31, 0xd57a55aa, 0x72822f6c, 0xa9a197b2, 0xd6ac27c8, 0x4761fa99, 0xf1f3dd67, 0x7fd6422e, 0x3b7b476b, 0x5c4b9a75, 0xc8ee9feb, 0x0021a5c2 }; 
    172          const gf2elem_t base_x     = { 0xbb7996a7, 0x60794e54, 0x5603aeab, 0x8a118051, 0xdc255a86, 0x34e59703, 0xb01ffe5b, 0xf1771d4d, 0x441cde4a, 0x64756260, 0x496b0c60, 0xd088ddb3, 0x015d4860 }; 
    173          const gf2elem_t base_y     = { 0x0273c706, 0x81c364ba, 0xd2181b36, 0xdf4b4f40, 0x38514f1f, 0x5488d08f, 0x0158aa4f, 0xa7bd198d, 0x7636b9c5, 0x24ed106a, 0x2bbfa783, 0xab6be5f3, 0x0061b1cf }; 
    174          const scalar_t  base_order = { 0xd9a21173, 0x8164cd37, 0x9e052f83, 0x5fa47c3c, 0xf33307be, 0xaad6a612, 0x000001e2, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01000000 }; 
    175           #endif
    176          
    177           #if (ECC_CURVE == NIST_K571)
    178            #define coeff_a  0
    179            #define cofactor 4
    180          /* NIST K-571 */
    181          const gf2elem_t polynomial = { 0x00000425, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x08000000 }; 
    182          const gf2elem_t coeff_b    = { 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 }; 
    183          const gf2elem_t base_x     = { 0xa01c8972, 0xe2945283, 0x4dca88c7, 0x988b4717, 0x494776fb, 0xbbd1ba39, 0xb4ceb08c, 0x47da304d, 0x93b205e6, 0x43709584, 0x01841ca4, 0x60248048, 0x0012d5d4, 0xac9ca297, 0xf8103fe4, 0x82189631, 0x59923fbc, 0x026eb7a8 }; 
    184          const gf2elem_t base_y     = { 0x3ef1c7a3, 0x01cd4c14, 0x591984f6, 0x320430c8, 0x7ba7af1b, 0xb620b01a, 0xf772aedc, 0x4fbebbb9, 0xac44aea7, 0x9d4979c0, 0x006d8a2c, 0xffc61efc, 0x9f307a54, 0x4dd58cec, 0x3bca9531, 0x4f4aeade, 0x7f4fbf37, 0x0349dc80 }; 
    185          const scalar_t  base_order = { 0x637c1001, 0x5cfe778f, 0x1e91deb4, 0xe5d63938, 0xb630d84b, 0x917f4138, 0xb391a8db, 0xf19a63e4, 0x131850e1, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02000000 }; 
    186           #endif
    187          
    188           #if (ECC_CURVE == NIST_B571)
    189            #define coeff_a  1
    190            #define cofactor 2
    191          /* NIST B-571 */
    192          const gf2elem_t polynomial = { 0x00000425, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x08000000 }; 
    193          const gf2elem_t coeff_b    = { 0x2955727a, 0x7ffeff7f, 0x39baca0c, 0x520e4de7, 0x78ff12aa, 0x4afd185a, 0x56a66e29, 0x2be7ad67, 0x8efa5933, 0x84ffabbd, 0x4a9a18ad, 0xcd6ba8ce, 0xcb8ceff1, 0x5c6a97ff, 0xb7f3d62f, 0xde297117, 0x2221f295, 0x02f40e7e }; 
    194          const gf2elem_t base_x     = { 0x8eec2d19, 0xe1e7769c, 0xc850d927, 0x4abfa3b4, 0x8614f139, 0x99ae6003, 0x5b67fb14, 0xcdd711a3, 0xf4c0d293, 0xbde53950, 0xdb7b2abd, 0xa5f40fc8, 0x955fa80a, 0x0a93d1d2, 0x0d3cd775, 0x6c16c0d4, 0x34b85629, 0x0303001d }; 
    195          const gf2elem_t base_y     = { 0x1b8ac15b, 0x1a4827af, 0x6e23dd3c, 0x16e2f151, 0x0485c19b, 0xb3531d2f, 0x461bb2a8, 0x6291af8f, 0xbab08a57, 0x84423e43, 0x3921e8a6, 0x1980f853, 0x009cbbca, 0x8c6c27a6, 0xb73d69d7, 0x6dccfffe, 0x42da639b, 0x037bf273 }; 
    196          const scalar_t  base_order = { 0x2fe84e47, 0x8382e9bb, 0x5174d66e, 0x161de93d, 0xc7dd9ca1, 0x6823851e, 0x08059b18, 0xff559873, 0xe661ce18, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x03ffffff }; 
    197           #endif
    198          
    199          #endif
    200          
    201          
    202          
    203          /*************************************************************************************************/
    204          
    205          /* Private / static functions: */
    206          
    207          
    208          /* some basic bit-manipulation routines that act on bit-vectors follow */
    209          static int bitvec_get_bit(const bitvec_t x, const uint32_t idx)
    210          {
    211            return ((x[idx / 32U] >> (idx & 31U) & 1U));
    212          }
    213          
    214          static void bitvec_clr_bit(bitvec_t x, const uint32_t idx)
    215          {
    216            x[idx / 32U] &= ~(1U << (idx & 31U));
    217          }
    218          
    219          static void bitvec_copy(bitvec_t x, const bitvec_t y)
    220          {
    221            int i;
    222            for (i = 0; i < BITVEC_NWORDS; ++i)
    223            {
    224              x[i] = y[i];
    225            }
    226          }
    227          
    228          static void bitvec_swap(bitvec_t x, bitvec_t y)
    229          {
    230            bitvec_t tmp;
    231            bitvec_copy(tmp, x);
    232            bitvec_copy(x, y);
    233            bitvec_copy(y, tmp);
    234          }
    235          
    236          #if defined(CONST_TIME) && (CONST_TIME == 0)
    237          /* fast version of equality test */
    238          static int bitvec_equal(const bitvec_t x, const bitvec_t y)
    239          {
    240            int i;
    241            for (i = 0; i < BITVEC_NWORDS; ++i)
    242            {
    243              if (x[i] != y[i])
    244              {
    245                return 0;
    246              }
    247            }
    248            return 1;
    249          }
    250          #else
    251          /* constant time version of equality test */
    252          static int bitvec_equal(const bitvec_t x, const bitvec_t y)
    253          {
    254            int ret = 1;
    255            int i;
    256            for (i = 0; i < BITVEC_NWORDS; ++i)
    257            {
    258              ret &= (x[i] == y[i]);
    259            }
    260            return ret;
    261          }
    262          #endif
    263          
    264          static void bitvec_set_zero(bitvec_t x)
    265          {
    266            int i;
    267            for (i = 0; i < BITVEC_NWORDS; ++i)
    268            {
    269              x[i] = 0;
    270            }
    271          }
    272          
    273          #if defined(CONST_TIME) && (CONST_TIME == 0)
    274          /* fast implementation */
    275          static int bitvec_is_zero(const bitvec_t x)
    276          {
    277            uint32_t i = 0;
    278            while (i < BITVEC_NWORDS)
    279            {
    280              if (x[i] != 0)
    281              {
    282                break;
    283              }
    284              i += 1;
    285            }
    286            return (i == BITVEC_NWORDS);
    287          }
    288          #else
    289          /* constant-time implementation */
    290          static int bitvec_is_zero(const bitvec_t x)
    291          {
    292            int ret = 1;
    293            int i = 0;
    294            for (i = 0; i < BITVEC_NWORDS; ++i)
    295            {
    296              ret &= (x[i] == 0);
    297            }
    298            return ret;
    299          }
    300          #endif
    301          
    302          /* return the number of the highest one-bit + 1 */
    303          static int bitvec_degree(const bitvec_t x)
    304          {
    305            int i = BITVEC_NWORDS * 32;
    306          
    307            /* Start at the back of the vector (MSB) */
    308            x += BITVEC_NWORDS;
    309          
    310            /* Skip empty / zero words */
    311            while (    (i > 0)
    312                    && (*(--x)) == 0)
    313            {
    314              i -= 32;
    315            }
    316            /* Run through rest if count is not multiple of bitsize of DTYPE */
    317            if (i != 0)
    318            {
    319              uint32_t u32mask = ((uint32_t)1 << 31);
    320              while (((*x) & u32mask) == 0)
    321              {
    322                u32mask >>= 1;
    323                i -= 1;
    324              }
    325            }
    326            return i;
    327          }
    328          
    329          /* left-shift by 'count' digits */
    330          static void bitvec_lshift(bitvec_t x, const bitvec_t y, int nbits)
    331          {
    332            int nwords = (nbits / 32);
    333          
    334            /* Shift whole words first if nwords > 0 */
    335            int i,j;
    336            for (i = 0; i < nwords; ++i)
    337            {
    338              /* Zero-initialize from least-significant word until offset reached */
    339              x[i] = 0;
    340            }
    341            j = 0;
    342            /* Copy to x output */
    343            while (i < BITVEC_NWORDS)
    344            {
    345              x[i] = y[j];
    346              i += 1;
    347              j += 1;
    348            }
    349          
    350            /* Shift the rest if count was not multiple of bitsize of DTYPE */
    351            nbits &= 31;
    352            if (nbits != 0)
    353            {
    354              /* Left shift rest */
    355              int i;
    356              for (i = (BITVEC_NWORDS - 1); i > 0; --i)
    357              {
    358                x[i]  = (x[i] << nbits) | (x[i - 1] >> (32 - nbits));
    359              }
    360              x[0] <<= nbits;
    361            }
    362          }
    363          
    364          
    365          /*************************************************************************************************/
    366          /*
    367            Code that does arithmetic on bit-vectors in the Galois Field GF(2^CURVE_DEGREE).
    368          */
    369          /*************************************************************************************************/
    370          
    371          
    372          static void gf2field_set_one(gf2elem_t x)
    373          {
    374            /* Set first word to one */
    375            x[0] = 1;
    376            /* .. and the rest to zero */
    377            int i;
    378            for (i = 1; i < BITVEC_NWORDS; ++i)
    379            {
    380              x[i] = 0;
    381            }
    382          }
    383          
    384          #if defined(CONST_TIME) && (CONST_TIME == 0)
    385          /* fastest check if x == 1 */
    386          static int gf2field_is_one(const gf2elem_t x) 
    387          {
    388            /* Check if first word == 1 */
    389            if (x[0] != 1)
    390            {
    391              return 0;
    392            }
    393            /* ...and if rest of words == 0 */
    394            int i;
    395            for (i = 1; i < BITVEC_NWORDS; ++i)
    396            {
    397              if (x[i] != 0)
    398              {
    399                break;
    400              }
    401            }
    402            return (i == BITVEC_NWORDS);
    403          }
    404          #else
    405          /* constant-time check */
    406          static int gf2field_is_one(const gf2elem_t x)
    407          {
    408            int ret = 0;
    409            /* Check if first word == 1 */
    410            if (x[0] == 1)
    411            {
    412              ret = 1;
    413            }
    414            /* ...and if rest of words == 0 */
    415            int i;
    416            for (i = 1; i < BITVEC_NWORDS; ++i)
    417            {
    418              ret &= (x[i] == 0);
    419            }
    420            return ret; //(i == BITVEC_NWORDS);
    421          }
    422          #endif
    423          
    424          
    425          /* galois field(2^m) addition is modulo 2, so XOR is used instead - 'z := a + b' */
    426          static void gf2field_add(gf2elem_t z, const gf2elem_t x, const gf2elem_t y)
    427          {
    428            int i;
    429            for (i = 0; i < BITVEC_NWORDS; ++i)
    430            {
    431              z[i] = (x[i] ^ y[i]);
    432            }
    433          }
    434          
    435          /* increment element */
    436          static void gf2field_inc(gf2elem_t x)
    437          {
    438            x[0] ^= 1;
    439          }
    440          
    441          
    442          /* field multiplication 'z := (x * y)' */
    443          static void gf2field_mul(gf2elem_t z, const gf2elem_t x, const gf2elem_t y)
    444          {
    445            int i;
    446            gf2elem_t tmp;
    447          #if defined(CONST_TIME) && (CONST_TIME == 1)
    448            gf2elem_t blind;
    449            bitvec_set_zero(blind);
    450          #endif
    451            assert(z != y);
    452          
    453            bitvec_copy(tmp, x);
    454          
    455            /* LSB set? Then start with x */
    456            if (bitvec_get_bit(y, 0) != 0)
    457            {
    458              bitvec_copy(z, x);
    459            }
    460            else /* .. or else start with zero */
    461            {
    462              bitvec_set_zero(z);
    463            }
    464          
    465            /* Then add 2^i * x for the rest */
    466            for (i = 1; i < CURVE_DEGREE; ++i)
    467            {
    468              /* lshift 1 - doubling the value of tmp */
    469              bitvec_lshift(tmp, tmp, 1);
    470          
    471              /* Modulo reduction polynomial if degree(tmp) > CURVE_DEGREE */
    472              if (bitvec_get_bit(tmp, CURVE_DEGREE))
    473              {
    474                gf2field_add(tmp, tmp, polynomial);
    475              }
    476          #if defined(CONST_TIME) && (CONST_TIME == 1)
    477              else /* blinding operation */
    478              {
    479                gf2field_add(tmp, tmp, blind);
    480              }
    481          #endif
    482          
    483              /* Add 2^i * tmp if this factor in y is non-zero */
    484              if (bitvec_get_bit(y, i))
    485              {
    486                gf2field_add(z, z, tmp);
    487              }
    488          #if defined(CONST_TIME) && (CONST_TIME == 1)
    489              else /* blinding operation */
    490              {
    491                gf2field_add(z, z, blind);
    492              }
    493          #endif
    494            }
    495          }
    496          
    497          /* field inversion 'z := 1/x' */
    498          static void gf2field_inv(gf2elem_t z, const gf2elem_t x)
    499          {
    500            gf2elem_t u, v, g, h;
    501            int i;
    502          
    503            bitvec_copy(u, x);
    504            bitvec_copy(v, polynomial);
    505            bitvec_set_zero(g);
    506            gf2field_set_one(z);
    507            
    508            while (!gf2field_is_one(u))
    509            {
    510              i = (bitvec_degree(u) - bitvec_degree(v));
    511          
    512              if (i < 0)
    513              {
    514                bitvec_swap(u, v);
    515                bitvec_swap(g, z);
    516                i = -i;
    517              }
    518          #if defined(CONST_TIME) && (CONST_TIME == 1)
    519              else
    520              {
    521                bitvec_swap(u, v);
    522                bitvec_swap(v, u);
    523              }
    524          #endif
    525              bitvec_lshift(h, v, i);
    526              gf2field_add(u, u, h);
    527              bitvec_lshift(h, g, i);
    528              gf2field_add(z, z, h);
    529            }
    530          }
    531          
    532          /*************************************************************************************************/
    533          /*
    534             The following code takes care of Galois-Field arithmetic. 
    535             Elliptic curve points are represented  by pairs (x,y) of bitvec_t. 
    536             It is assumed that curve coefficient 'a' is {0,1}
    537             This is the case for all NIST binary curves.
    538             Coefficient 'b' is given in 'coeff_b'.
    539             '(base_x, base_y)' is a point that generates a large prime order group.
    540          */
    541          /*************************************************************************************************/
    542          
    543          
    544          static void gf2point_copy(gf2elem_t x1, gf2elem_t y1, const gf2elem_t x2, const gf2elem_t y2)
    545          {
    546            bitvec_copy(x1, x2);
    547            bitvec_copy(y1, y2);
    548          }
    549          
    550          static void gf2point_set_zero(gf2elem_t x, gf2elem_t y)
    551          {
    552            bitvec_set_zero(x);
    553            bitvec_set_zero(y);
    554          }
    555          
    556          static int gf2point_is_zero(const gf2elem_t x, const gf2elem_t y)
    557          {
    558            return (    bitvec_is_zero(x)
    559                     && bitvec_is_zero(y));
    560          }
    561          
    562          /* double the point (x,y) */
    563          static void gf2point_double(gf2elem_t x, gf2elem_t y)
    564          {
    565            /* iff P = O (zero or infinity): 2 * P = P */
    566            if (bitvec_is_zero(x))
    567            {
    568              bitvec_set_zero(y);
    569            }
    570            else
    571            {
    572              gf2elem_t l;
    573          
    574              gf2field_inv(l, x);
    575              gf2field_mul(l, l, y);
    576              gf2field_add(l, l, x);
    577              gf2field_mul(y, x, x);
    578              gf2field_mul(x, l, l);
    579          #if (coeff_a == 1)
    580              gf2field_inc(l);
    581          #endif
    582              gf2field_add(x, x, l);
    583              gf2field_mul(l, l, x);
    584              gf2field_add(y, y, l);
    585            }
    586          }
    587          
    588          
    589          /* add two points together (x1, y1) := (x1, y1) + (x2, y2) */
    590          static void gf2point_add(gf2elem_t x1, gf2elem_t y1, const gf2elem_t x2, const gf2elem_t y2)
    591          {
    592            if (!gf2point_is_zero(x2, y2))
    593            {
    594              if (gf2point_is_zero(x1, y1))
    595              {
    596                gf2point_copy(x1, y1, x2, y2);
    597              }
    598              else
    599              {
    600                if (bitvec_equal(x1, x2))
    601                {
    602                  if (bitvec_equal(y1, y2))
    603                  {
    604                    gf2point_double(x1, y1);
    605                  }
    606                  else
    607                  {
    608                    gf2point_set_zero(x1, y1);
    609                  }
    610                }
    611                else
    612                {
    613                  /* Arithmetic with temporary variables */
    614                  gf2elem_t a, b, c, d;
    615          
    616                  gf2field_add(a, y1, y2);
    617                  gf2field_add(b, x1, x2);
    618                  gf2field_inv(c, b);
    619                  gf2field_mul(c, c, a);
    620                  gf2field_mul(d, c, c);
    621                  gf2field_add(d, d, c);
    622                  gf2field_add(d, d, b);
    623          #if (coeff_a == 1)
    624                  gf2field_inc(d);
    625          #endif
    626                  gf2field_add(x1, x1, d);
    627                  gf2field_mul(a, x1, c);
    628                  gf2field_add(a, a, d);
    629                  gf2field_add(y1, y1, a);
    630                  bitvec_copy(x1, d);
    631                }
    632              }
    633            }
    634          }
    635          
    636          
    637          
    638          #if defined(CONST_TIME) && (CONST_TIME == 0)
    639          /* point multiplication via double-and-add algorithm */
    640          static void gf2point_mul(gf2elem_t x, gf2elem_t y, const scalar_t exp)
    641          {
    642            gf2elem_t tmpx, tmpy;
    643            int i;
    644            int nbits = bitvec_degree(exp);
    645          
    646            gf2point_set_zero(tmpx, tmpy);
    647          
    648            for (i = (nbits - 1); i >= 0; --i)
    649            {
    650              gf2point_double(tmpx, tmpy);
    651              if (bitvec_get_bit(exp, i))
    652              {
    653                gf2point_add(tmpx, tmpy, x, y);
    654              }
    655            }
    656            gf2point_copy(x, y, tmpx, tmpy);
    657          }
    658          #else
    659          /* point multiplication via double-and-add-always algorithm using scalar blinding */
    660          static void gf2point_mul(gf2elem_t x, gf2elem_t y, const scalar_t exp)
    661          {
    662            gf2elem_t tmpx, tmpy;
    663            gf2elem_t dummyx, dummyy;
    664            int i;
    665            int nbits = bitvec_degree(exp);
    666          
    667            gf2point_set_zero(tmpx, tmpy);
    668            gf2point_set_zero(dummyx, dummyy);
    669          
    670            for (i = (nbits - 1); i >= 0; --i)
    671            {
    672              gf2point_double(tmpx, tmpy);
    673          
    674              /* Add point if bit(i) is set in exp */
    675              if (bitvec_get_bit(exp, i))
    676              {
    677                gf2point_add(tmpx, tmpy, x, y);
    678              }
    679              /* .. or add the neutral element to keep operation constant-time */
    680              else
    681              {
    682                gf2point_add(tmpx, tmpy, dummyx, dummyy);
    683              }
    684            }
    685            gf2point_copy(x, y, tmpx, tmpy);
    686          }
    687          #endif
    688          
    689          
    690          
    691          /* check if y^2 + x*y = x^3 + a*x^2 + coeff_b holds */
    692          static int gf2point_on_curve(const gf2elem_t x, const gf2elem_t y)
    693          {
    694            gf2elem_t a, b;
    695          
    696            if (gf2point_is_zero(x, y))
    697            {
    698              return 1;
    699            }
    700            else
    701            {
    702              gf2field_mul(a, x, x);
    703          #if (coeff_a == 0)
    704              gf2field_mul(a, a, x);
    705          #else
    706              gf2field_mul(b, a, x);
    707              gf2field_add(a, a, b);
    708          #endif
    709              gf2field_add(a, a, coeff_b);
    710              gf2field_mul(b, y, y);
    711              gf2field_add(a, a, b);
    712              gf2field_mul(b, x, y);
    713          
    714              return bitvec_equal(a, b);
    715            }
    716          }
    717          
    718          
    719          /*************************************************************************************************/
    720          /*
    721            Elliptic Curve Diffie-Hellman key exchange protocol.
    722          */
    723          /*************************************************************************************************/
    724          
    725          
    726          
    727          /* NOTE: private should contain random data a-priori! */
    728          int ecdh_generate_keys(uint8_t* public_key, uint8_t* private_key)
    729          {
    730            /* Get copy of "base" point 'G' */
    731            gf2point_copy((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), base_x, base_y);
    732          
    733            /* Abort key generation if random number is too small */
    734            if (bitvec_degree((uint32_t*)private_key) < (CURVE_DEGREE / 2))
    735            {
    736              return 0;
    737            }
    738            else
    739            {
    740              /* Clear bits > CURVE_DEGREE in highest word to satisfy constraint 1 <= exp < n. */
    741              int nbits = bitvec_degree(base_order);
    742              int i;
    743          
    744              for (i = (nbits - 1); i < (BITVEC_NWORDS * 32); ++i)
    745              {
    746                bitvec_clr_bit((uint32_t*)private_key, i);
    747              }
    748          
    749              /* Multiply base-point with scalar (private-key) */
    750              gf2point_mul((uint32_t*)public_key, (uint32_t*)(public_key + BITVEC_NBYTES), (uint32_t*)private_key);
    751              return 1;
    752            }
    753          }
    754          
    755          
    756          
    757          int ecdh_shared_secret(const uint8_t* private_key, const uint8_t* others_pub, uint8_t* output)
    758          {
    759            /* Do some basic validation of other party's public key */
    760            if (    !gf2point_is_zero ((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES))
    761                 &&  gf2point_on_curve((uint32_t*)others_pub, (uint32_t*)(others_pub + BITVEC_NBYTES)) )
    762            {
    763              /* Copy other side's public key to output */
    764              unsigned int i;
    765              for (i = 0; i < (BITVEC_NBYTES * 2); ++i)
    766              {
    767                output[i] = others_pub[i];
    768              }
    769          
    770              /* Multiply other side's public key with own private key */
    771              gf2point_mul((uint32_t*)output,(uint32_t*)(output + BITVEC_NBYTES), (const uint32_t*)private_key);
    772          
    773              /* Multiply outcome by cofactor if using ECC CDH-variant: */
    774          #if defined(ECDH_COFACTOR_VARIANT) && (ECDH_COFACTOR_VARIANT == 1)
    775           #if   (cofactor == 2)
    776              gf2point_double((uint32_t*)output, (uint32_t*)(output + BITVEC_NBYTES));
    777           #elif (cofactor == 4)
    778              gf2point_double((uint32_t*)output, (uint32_t*)(output + BITVEC_NBYTES));
    779              gf2point_double((uint32_t*)output, (uint32_t*)(output + BITVEC_NBYTES));
    780           #endif
    781          #endif
    782              
    783              return 1;
    784            }
    785            else
    786            {
    787              return 0;
    788            }
    789          }
    790          
    791          
    792          /* ECDSA is broken :( ... */
    793          int ecdsa_sign(const uint8_t* private_key, uint8_t* hash, uint8_t* random_k, uint8_t* signature)
    794          {
    795            /*
    796               1) calculate e = HASH(m)
    797               2) let z be the Ln leftmost bits of e, where Ln is the bit length of the group order n
    798               3) Select a cryptographically secure random integer k from [1, n-1]
    799               4) Calculate the curve point (x1, y1) = k * G
    800               5) Calculate r = x1 mod n - if (r == 0) goto 3
    801               6) Calculate s = inv(k) * (z + r * d) mod n - if (s == 0) goto 3
    802               7) The signature is the pair (r, s)
    803            */
    804            assert(private_key != 0);
    805            assert(hash != 0);
    806            assert(random_k != 0);
    807            assert(signature != 0);
    808          
    809            int success = 0;
    810          
    811            if (    (bitvec_degree((uint32_t*)private_key) >= (CURVE_DEGREE / 2))
    812                 && !bitvec_is_zero((uint32_t*)random_k) )
    813            {
    814              gf2elem_t r, s, z, k;
    815          
    816              bitvec_set_zero(r);
    817              bitvec_set_zero(s);
    818              bitvec_copy(z, (uint32_t*)hash);
    819          
    820              /* 1 + 2 */
    821              int nbits = bitvec_degree(base_order);
    822              int i;
    823              for (i = (nbits - 1); i < BITVEC_NBITS; ++i)
    824              {
    825                bitvec_clr_bit(z, i);
    826              }
    827          
    828              /* 3 */
    829              bitvec_copy(k, (uint32_t*)random_k);
    830          
    831              /* 4 */
    832              gf2point_copy(r, s, base_x, base_y);
    833              gf2point_mul(r, s, k);
    834          
    835              /* 5 */
    836              if (!bitvec_is_zero(r))
    837              {
    838                /* 6) s = inv(k) * (z + (r * d)) mod n ==> if (s == 0) goto 3 **/
    839                gf2field_inv(s, k);                     /* s = inv(k) */
    840                gf2field_mul(r, r, (uint32_t*)private_key); /* r = (r * d) */
    841                gf2field_add(r, r, z);                  /* r = z + (r * d) */
    842          
    843                nbits = bitvec_degree(r); /* r = r mod n */
    844                for (i = (nbits - 1); i < BITVEC_NBITS; ++i)
    845                {
    846                  printf("reduction r\n");
    847                  bitvec_clr_bit(r, i);
    848                }
    849                
    850                gf2field_mul(s, s, r);                  /* s = inv(k) * (z * (r * d)) */
    851          
    852                nbits = bitvec_degree(s); /* s = s mod n */
    853                for (i = (nbits - 1); i < BITVEC_NBITS; ++i)
    854                {
    855                  printf("reduction s\n");
    856                  bitvec_clr_bit(s, i);
    857                }
    858          
    859                if (!bitvec_is_zero(s))
    860                {
    861                  bitvec_copy((uint32_t*)signature, r);
    862                  bitvec_copy((uint32_t*)(signature + ECC_PRV_KEY_SIZE), s);
    863                  success = 1;
    864                }
    865              }
    866            }
    867            return success;
    868          }
    869          
    870          
    871          int ecdsa_verify(const uint8_t* public_key, uint8_t* hash, const uint8_t* signature)
    872          {
    873            /*
    874              1) Verify that (r,s) are in [1, n-1]
    875              2) e = HASH(m)
    876              3) z = Ln leftmost bits of e
    877              4) w = inv(s) mod n
    878              5) u1 = (z * w) mod n
    879                 u2 = (r * w) mod n
    880              6) (x,y) = (u1 * G) + (u2 * public)
    881              7) Signature is valid if r == x mod n && (x,y) != (0,0)
    882            */
    883            assert(public_key != 0);
    884            assert(hash != 0);
    885            assert(signature != 0);
    886          
    887            int success = 0;
    888          
    889            gf2elem_t r, s;
    890            bitvec_copy(r, (uint32_t*)(signature));
    891            bitvec_copy(s, (uint32_t*)(signature + ECC_PRV_KEY_SIZE));
    892          
    893            if (    !bitvec_is_zero(s)
    894                 && !bitvec_is_zero(r))
    895            {
    896              gf2elem_t x1, y1, u1, u2, w, z;
    897          
    898              /* 3) z = Ln leftmost bits of e */
    899              bitvec_copy(z, (uint32_t*)hash); /* r,s,z are set */
    900              uint32_t nbits = bitvec_degree(base_order);
    901              uint32_t i;
    902              for (i = (nbits - 1); i < BITVEC_NBITS; ++i)
    903              {
    904                bitvec_clr_bit(z, i);
    905              }
    906              
    907              /* 4) w = inv(s) mod n */
    908              gf2field_inv(w, s); /* w = inv(s) */
    909              /* Modulo reduction polynomial if degree(tmp) > CURVE_DEGREE */
    910              if (bitvec_get_bit(w, CURVE_DEGREE))
    911              {
    912                printf("reduction on w\n");
    913                gf2field_add(w, w, polynomial);
    914              }
    915          
    916              /* 5) u1 = zw mod n, u2 = rw mod n*/
    917              gf2field_mul(u1, z, w); /* u1 = z * w */
    918              /* Modulo reduction polynomial if degree(tmp) > CURVE_DEGREE */
    919              if (bitvec_get_bit(u1, CURVE_DEGREE))
    920              {
    921                printf("reduction on u1\n");
    922                gf2field_add(u1, u1, polynomial);
    923              }
    924              gf2field_mul(u2, r, w); /* u2 = r * w */
    925              /* Modulo reduction polynomial if degree(tmp) > CURVE_DEGREE */
    926              if (bitvec_get_bit(u2, CURVE_DEGREE))
    927              {
    928                printf("reduction on u2\n");
    929                gf2field_add(u2, u2, polynomial);
    930              }
    931          
    932              /* 6) (x,y) = (u1 * G) + (u2 * public) */
    933              bitvec_copy(x1, base_x);
    934              bitvec_copy(y1, base_y);
    935              gf2field_mul(u1, x1, y1);  /* u1 * G */
    936          
    937              bitvec_copy(w, (uint32_t*)(public_key));
    938              bitvec_copy(z, (uint32_t*)(public_key + ECC_PRV_KEY_SIZE));
    939              gf2field_mul(u2, w, z); /* u2 * Q */
    940          
    941              
    942              gf2point_add(x1, y1, w, z);
    943              if (bitvec_get_bit(x1, CURVE_DEGREE))
    944              {
    945                printf("reduction on x1\n");
    946                gf2field_add(x1, x1, polynomial);
    947              }
    948          
    949              success = bitvec_equal(r, x1);
    950          
    951              if (!success)
    952              {
    953                printf("x = '");
    954                for (i = 0; i < BITVEC_NWORDS; ++i)
    955                {
    956                  printf("%.08x", x1[i]);
    957                }
    958                printf("' [%u]\n", i);
    959                printf("r = '");
    960                for (i = 0; i < BITVEC_NWORDS; ++i)
    961                {
    962                  printf("%.08x", r[i]);
    963                }
    964                printf("' [%u]\n", i);
    965              }
    966            }
    967            else
    968            {
    969              printf("(s or r) == zero\n");
    970            }
    971          
    972            return success;
    973          }
    974          
    975          
    976          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   bitvec_clr_bit
       8   bitvec_copy
       4   bitvec_degree
       8   bitvec_equal
       0   bitvec_get_bit
       4   bitvec_is_zero
      16   bitvec_lshift
        16 __aeabi_idiv
       4   bitvec_set_zero
      48   bitvec_swap
        48   -> bitvec_copy
      16   ecdh_generate_keys
        16   -> bitvec_clr_bit
        16   -> bitvec_degree
        16   -> gf2point_copy
        16   -> gf2point_mul
      16   ecdh_shared_secret
        16   -> gf2point_is_zero
        16   -> gf2point_mul
        16   -> gf2point_on_curve
     152   ecdsa_sign
       152   -> __aeabi_assert
       152   -> __iar_EmptyStepPoint
       152   -> bitvec_clr_bit
       152   -> bitvec_copy
       152   -> bitvec_degree
       152   -> bitvec_is_zero
       152   -> bitvec_set_zero
       152   -> gf2field_add
       152   -> gf2field_inv
       152   -> gf2field_mul
       152   -> gf2point_copy
       152   -> gf2point_mul
       152   -> printf
     280   ecdsa_verify
       280   -> __aeabi_assert
       280   -> __iar_EmptyStepPoint
       280   -> bitvec_clr_bit
       280   -> bitvec_copy
       280   -> bitvec_degree
       280   -> bitvec_equal
       280   -> bitvec_get_bit
       280   -> bitvec_is_zero
       280   -> gf2field_add
       280   -> gf2field_inv
       280   -> gf2field_mul
       280   -> gf2point_add
       280   -> printf
      12   gf2field_add
       0   gf2field_inc
     144   gf2field_inv
       144   -> bitvec_copy
       144   -> bitvec_degree
       144   -> bitvec_lshift
       144   -> bitvec_set_zero
       144   -> bitvec_swap
       144   -> gf2field_add
       144   -> gf2field_is_one
       144   -> gf2field_set_one
       4   gf2field_is_one
      48   gf2field_mul
        48   -> __aeabi_assert
        48   -> __iar_EmptyStepPoint
        48   -> bitvec_copy
        48   -> bitvec_get_bit
        48   -> bitvec_lshift
        48   -> bitvec_set_zero
        48   -> gf2field_add
       4   gf2field_set_one
     152   gf2point_add
       152   -> bitvec_copy
       152   -> bitvec_equal
       152   -> gf2field_add
       152   -> gf2field_inc
       152   -> gf2field_inv
       152   -> gf2field_mul
       152   -> gf2point_copy
       152   -> gf2point_double
       152   -> gf2point_is_zero
       152   -> gf2point_set_zero
      16   gf2point_copy
        16   -> bitvec_copy
      48   gf2point_double
        48   -> bitvec_is_zero
        48   -> bitvec_set_zero
        48   -> gf2field_add
        48   -> gf2field_inc
        48   -> gf2field_inv
        48   -> gf2field_mul
       8   gf2point_is_zero
         8   -> bitvec_is_zero
      88   gf2point_mul
        88   -> bitvec_degree
        88   -> bitvec_get_bit
        88   -> gf2point_add
        88   -> gf2point_copy
        88   -> gf2point_double
        88   -> gf2point_set_zero
      80   gf2point_on_curve
        80   -> bitvec_equal
        80   -> gf2field_add
        80   -> gf2field_mul
        80   -> gf2point_is_zero
       8   gf2point_set_zero
         8   -> bitvec_set_zero


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable3
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       8  ?_0
      60  ?_1
      20  ?_10
      20  ?_11
      20  ?_12
       8  ?_13
       8  ?_14
       8  ?_15
       8  ?_16
      20  ?_17
      20  ?_2
      12  ?_3
      16  ?_4
      16  ?_5
      16  ?_6
      16  ?_7
      16  ?_8
      16  ?_9
      32  base_order
      32  base_x
      32  base_y
      34  bitvec_clr_bit
      26  bitvec_copy
      50  bitvec_degree
      36  bitvec_equal
      22  bitvec_get_bit
      38  bitvec_is_zero
     118  bitvec_lshift
      22  bitvec_set_zero
      36  bitvec_swap
      32  coeff_b
      76  ecdh_generate_keys
      70  ecdh_shared_secret
     332  ecdsa_sign
     454  ecdsa_verify
      34  gf2field_add
      10  gf2field_inc
     128  gf2field_inv
      48  gf2field_is_one
     134  gf2field_mul
      26  gf2field_set_one
     220  gf2point_add
      22  gf2point_copy
     114  gf2point_double
      34  gf2point_is_zero
      84  gf2point_mul
     106  gf2point_on_curve
      16  gf2point_set_zero
      32  polynomial

 
   468 bytes in section .rodata
 2 434 bytes in section .text
 
 2 434 bytes of CODE  memory
   468 bytes of CONST memory

Errors: none
Warnings: 8
